nocoiner
========

<div align="center">
  <img
    src="https://marcoonroad.dev/nocoiner/images/nocoiner.png"
    width="200"
    height="200"
    alt="nocoiner logo"/>
</div>

<div align="center">
  <p>
    <span>A Commitment Scheme library for Coin Flipping/Tossing algorithms and sort.</span>
  </p>
</div>

<div align="center">
<!-- Travis CI badge -->
<a
  style="margin: 0.1em;"
  href="https://travis-ci.com/marcoonroad/nocoiner"
  title="Verify the build logs here."><img
  src="https://img.shields.io/travis/com/marcoonroad/nocoiner.svg?logo=travis&style=flat-square"/></a>
<!-- Coveralls badge -->
<a
  style="margin: 0.1em;"
  href="https://coveralls.io/github/marcoonroad/nocoiner"
  title="Verify the detailed test coverage here."><img
  src="https://img.shields.io/coveralls/github/marcoonroad/nocoiner.svg?style=flat-square"/></a>
<!-- License badge -->
<a
  style="margin: 0.1em;"
  href="https://github.com/marcoonroad/nocoiner/blob/master/LICENSE"
  title="Verify the project license here."><img
  src="https://img.shields.io/github/license/marcoonroad/nocoiner.svg?style=flat-square&logo=github"/></a>
<!-- Open PR badge -->
<a
  style="margin: 0.1em;"
  href="https://github.com/marcoonroad/nocoiner/compare"
  title="Interested in contribute with this project?"><img
  src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&logo=github"/></a>
<!-- GitHub latest release/tag -->
<a
  style="margin: 0.1em;"
  href="https://github.com/marcoonroad/nocoiner/releases"
  title="Check the GitHub repository releases here."><img
  src="https://img.shields.io/github/tag-date/marcoonroad/nocoiner?logo=github&style=flat-square"></a>
<!-- Donate BTC badge -->
<a
  style="margin: 0.1em;"
  href="https://www.blockchain.com/btc/address/13jnVxMenKUWb1RA1pKsQkri5HY1u89o2D"
  title="Want to give a little donation for author?"><img
  src="https://img.shields.io/badge/donate-BTC-yellow.svg?logo=bitcoin&style=flat-square"/></a>
</div>

<div align="center">
<!-- Docker build type badge -->
<a
  style="margin: 0.1em;"
  href="https://hub.docker.com/r/marcoonroad/nocoiner/builds"
  title="Check the Docker project build here."><img
  alt="Docker Cloud Automated build"
  src="https://img.shields.io/docker/cloud/automated/marcoonroad/nocoiner.svg?style=flat-square&logo=docker"></a>
<!-- Docker build test badge -->
<a
  style="margin: 0.1em;"
  href="https://hub.docker.com/r/marcoonroad/nocoiner/builds"
  title="Check the Docker project build here."><img
  alt="Docker Cloud Build Status"
  src="https://img.shields.io/docker/cloud/build/marcoonroad/nocoiner.svg?style=flat-square&logo=docker"></a>
<!-- Docker layers badge -->
<a
  style="margin: 0.1em;"
  href="https://microbadger.com/images/marcoonroad/nocoiner"
  title="Verify the Docker image details here."><img
  src="https://img.shields.io/microbadger/layers/marcoonroad/nocoiner/latest.svg?style=flat-square&logo=docker"/></a>
<!-- Docker size badge -->
<a
  style="margin: 0.1em;"
  href="https://microbadger.com/images/marcoonroad/nocoiner"
  title="Verify the Docker image details here."><img
  src="https://img.shields.io/microbadger/image-size/marcoonroad/nocoiner.svg?style=flat-square&logo=docker"/></a>
<!-- Docker pulls badge -->
<a
  style="margin: 0.1em;"
  href="https://hub.docker.com/r/marcoonroad/nocoiner"
  title="Check the Docker project repository here."><img
  src="https://img.shields.io/docker/pulls/marcoonroad/nocoiner.svg?style=flat-square&logo=docker"/></a>
<!-- Docker stars badge -->
<a
  style="margin: 0.1em;"
  href="https://hub.docker.com/r/marcoonroad/nocoiner"
  title="Check the Docker project repository here."><img
  src="https://img.shields.io/docker/stars/marcoonroad/nocoiner.svg?style=flat-square&logo=docker"/></a>
</div>

---

**NOTICE:** The previous version (`0.0.1`) of this API used the Galois/Counter Mode encryption.
This authenticated encryption algorithm is not a committing encryption (that's, a
_lockable box_). The main reason is the weakness of the internal GCM hash against Collision
Attacks (a hash with 256-bits or 512-bits images would be likely resistant, but GCM uses
128-bits of output/digest images). For more details, please refer to the historical issue [here][9].
The new API, therefore, breaks if you try to reveal/open commitments generated by the previous API.

---


### About

This project implements [Commitment Schemes][1] using the
[Encrypt-then-MAC][2] approach of authenticated encryption. Because this kind of
encryption algorithm provides both Message _Confidentiality_ and _Integrity_, it fits
perfectly the _Hiding_ and _Binding_ properties of Commitment Schemes.
Confidentiality protects the message against _passive attacks_ while integrity
protects it from _active attacks_.

The hiding property states that it is impossible to discover the secret with the
commitment data left alone, that is, the commitment receiver can't know the
secret until the commitment sender reveals that through her opening key.

The binding property, on the other hand, ensures invariants on the commitment
sender side. It disallows the sender to change the secret by using a different
opening key. While the sender can refuse to reveal her secret, she can't cheat
on the game. There's a variant of commitment schemes called _Timed Commitments_
where the receiver can brute-force the commitment in the case of the sender
aborting the game by refusing to send the opening key, tho. Another variant
called _Fuzzy Commitments_ accepts some noise during opening phase.

Commitment Schemes are one of the many [Secure Multiparty Computation][3]
protocols/primitives, [Secret Sharing][4] is other famous cryptographic
primitive in such field.


### Installation

For the stable release, just type:

```shell
$ opam install nocoiner
```

To install/test the unstable version on this repository (assuming you're
inside the project's root directory):

```shell
$ make install # 'make uninstall' reverts the changes
```


### Testing

```shell
$ make test
```


### Usage

As library (assuming you have linked the package `nocoiner` below):

```ocaml
let secret = "I have nothing to hide."
let (c, o) = Nocoiner.commit secret

assert (secret = Nocoiner.reveal ~commitment:c ~opening:o)
```

Here, the `Nocoiner.commit` operation is non-deterministic and the
`Nocoiner.reveal` is deterministic. The `Nocoiner.reveal` operation may throw
the following exceptions:
- `Nocoiner.Reasons.InvalidCommitment`, if the parsing of commitment fails.
- `Nocoiner.Reasons.InvalidOpening`, if the opening key contains invalid data.
- `Nocoiner.Reasons.BindingFailure`, if both commitment & opening are unrelated.

As the command-line interface (ignore all the `$` below while typing):

```shell
$ echo "Something not really secret..." > secret.txt
$ cat secret.txt | nocoiner commit \
  --commitment-file=commitment-box.txt \
  --opening-file=opening-key.txt
$ nocoiner reveal \
  --commitment-file=commitment-box.txt \
  --opening-file=opening-key.txt > secret-output.txt
$ cat secret-output.txt
```

The complete API reference is available [here][7]. Coverage reports are
generated too, please refer to the respective [page][8].


### Cryptoanalysis

We have performed some benchmarks on valid inputs and on invalid inputs as well.
This is just to discover and prove exploitable loopholes. The kind of side-channel
vulnerabilities shown on version `1.0.0` are related to _timing attacks_. The used
_Key Derivation Function_ on both `commit` and `reveal` phases conceals a lot the
response time if this library is used as an _oracle_ (that is, an external server).
On the other hand, this algorithm is open and then the attacker can pre-compute the
derivation keys, and just perform her own cryptoanalysis on the next steps of the
algorithm.

Assuming that our _Nocoiner_ algorithm is just a black-box (oracle) where all the
steps are called "atomically", there are still some exploitable information if the
attacker gains access on the host machine for the oracle service. The benchmarks
provided with the `core_bench` library only work well for functions halting under
milliseconds, the KDF imposes a computation around few seconds. Due that issue, we
execute the benchmarks with a lower KDF cost (just to cover the possibility of
pre-computed derived keys, and also to remove timing noise imposed by a KDF with
stronger cycles). To run the benchmarks, just type `$ make bench` on this project's
root directory.

We will only take the relevant information (with major differences). The version
`1.0.0` is vulnerable during the opening phase, mostly 'cause:

- We compare the tags for the authenticated ciphertext in non-constant /
  non-linear time. This is the most famous kind of exploitable timing attack.
- We don't decypher the AES ciphertext even if the opening key is wrong (don't
  pass the MAC tag test). The result plaintext will be ignored 'cause the
  authentication failed, but decryption must be performed to not leak side
  information for the attacker.

The benchmarks results stored on this repository were performed on an Intel(R)
Dual-Core Celeron(R) of 1GHz each (both vulnerable to Meltdown, Spectre and MDS
CPU bugs, and possibly some NSA hardware backdoors too, you know). The first test
is the one with valid inputs, and the rest are evaluated with invalid inputs:

<p></p>

| Name               | Time/Run | Cycls/Run | mWd/Run | mWd Overhd | mjWd/Run | mjWd Overhd |  mGC/Run | Percentage |
|:-------------------|---------:|----------:|--------:|-----------:|---------:|------------:|---------:|-----------:|
| bound opening      | 830.05us |  863.66kc | 19.77kw |     24.18w |   17.87w |     116.97w | 70.61e-3 |    100.00% |
| unbound commitment | 809.76us |  842.54kc | 19.56kw |     28.59w |   20.29w |    -219.19w | 69.79e-3 |     97.56% |
| unbound opening    | 807.82us |  840.52kc | 19.56kw |     28.59w |   20.29w |    -219.19w | 69.79e-3 |     97.32% |

<div align="center" style="text-align: center;"><center>
<i>This table shows informations about the GC, minor heap & major heap. All cases
were executed with major heap compaction disabled to not mask execution time.</i>
</center></div>

<p></p>

TODO.


### Disclaimer

This library was not fully tested against side-channel attacks. Keep in mind
that the use cases of this library is for Secure Multiparty games such as online
Gambling and Auctions. With other use cases, the security of this cryptographic
primitive can be deemed as flawed.

Note that players can abort in the middle of a Commit-and-Reveal game, so you
should as well deal with that on your code logic. The random encryption key
and input vector only ensure the _uniqueness locally_, it's also possible to
happen collisions of both random data on a distributed setting (it's due the
sources of entropy being remote and different - so commitments and openings
would be identical, think on that even if this probability is small). ~~In such
case, you can either take a fingerprint of the host machine and a timestamp
nonce into account, in the same sense of [Elliott's CUID][5] library~~ (we already
cover that issue of distributed collisions by using a fingerprint of hashed
process context).

  [1]: https://en.wikipedia.org/wiki/Commitment_scheme
  [2]: https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC
  [3]: https://en.wikipedia.org/wiki/Secure_multiparty_computation
  [4]: https://en.wikipedia.org/wiki/Secret_sharing
  [5]: https://github.com/ericelliott/cuid
  [6]: https://en.wikipedia.org/wiki/Authenticated_encryption
  [7]: https://marcoonroad.dev/nocoiner/apiref/nocoiner/Nocoiner/index.html
  [8]: https://marcoonroad.dev/nocoiner/apicov/index.html
  [9]: https://github.com/marcoonroad/nocoiner/issues/1